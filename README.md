# 선착순 쿠폰 발급 시스템

설정 가능한 파라미터를 통해 시간 기반 쿠폰 캠페인의 동시 요청을 처리하도록 설계된 고성능 쿠폰 발급 시스템입니다.

## 프로젝트 개요

이 프로젝트는 다음과 같은 특징을 가진 쿠폰 발급 시스템을 구현합니다:
- 설정 가능한 파라미터(발급 수량, 시작/만료 날짜)를 통한 캠페인 관리
- 지정된 시간에 선착순 방식의 쿠폰 발급
- 높은 트래픽(초당 500-1,000 요청) 처리 -> [부하 테스트 수행 바로가기](tests/k6/README.md)
- 동시 작업 중 데이터 일관성 보장
- 고유한 쿠폰 코드 생성(한글, 숫자 로 구성되며 10글자 내외)

이 시스템은 다음을 보장합니다:
1. 캠페인별로 정확히 지정된 수의 쿠폰만 발급
2. 쿠폰 발급이 정확히 지정된 날짜와 시간에 시작
3. 발급 과정 전체에서 데이터 일관성 유지
4. 각 쿠폰은 고유한 코드를 가짐 (최대 10자, 한글 문자와 숫자로 구성)

## 시스템 아키텍처

이 프로젝트는 DDD 원칙을 **일부** 따릅니다:

```
coupon-service/
├── api/                      # API 레이어 (gRPC 인터페이스)
│   └── grpc/
│       └── service/          # gRPC 서비스 구현
├── cmd/                      # 애플리케이션 진입점
├── internal/                 # 내부 패키지
│   ├── application/          # 애플리케이션 서비스
│   ├── config/               # 설정
│   ├── domain/               # 도메인 모델 및 비즈니스 로직
│   ├── infrastructure/       # 인프라 구현
│   │   ├── cache/            # Redis 캐시 클라이언트
│   │   ├── entity/           # 데이터베이스 엔티티
│   │   └── repository/       # 레포지토리 구현
│   └── test/                 # 테스트 유틸리티
└──docker-compose.yml         # 로컬 개발용 Docker 컴포즈
```

## 주요 기능

### 1. 캠페인 관리
- 맞춤 설정 가능한 파라미터로 쿠폰 캠페인 생성
- 발급 수량, 시작 날짜, 만료 날짜 구성
- 각 캠페인별 발급된 쿠폰 추적

### 2. 쿠폰 발급
- 선착순 원칙에 따른 쿠폰 발급
- 캠페인 시작 및 만료 날짜 강제
- 한글 문자와 숫자를 결합한 고유 쿠폰 코드 생성
- 동일 사용자에게 중복 발급 방지

### 3. 동시성 제어
- 높은 트래픽 시나리오 처리(초당 500-1,000 요청)
- 정확히 지정된 수의 쿠폰만 발급되도록 보장
- 분산 잠금 메커니즘을 통한 데이터 일관성 유지

## 기술 스택

- **언어**: Go 1.24
- **API 프레임워크**: ConnectRPC
- **데이터베이스**: MySQL with GORM
- **캐시**: Redis (동시성 제어 및 성능 향상용)
- **컨테이너**: Docker 및 Docker Compose
- **테스트**: Go 테스트 프레임워크와 testcontainers

## API 문서

이 서비스는 다음과 같은 gRPC 메서드를 구현합니다:

### CreateCampaign
지정된 파라미터로 새 쿠폰 캠페인을 생성합니다.

**요청:**
```proto
message CreateCampaignRequest {
  string name = 1;
  int64 amount = 2;
  google.protobuf.Timestamp issued_at = 3;
  google.protobuf.Timestamp expires_at = 4;
}
```

### GetCampaign
성공적으로 발급된 모든 쿠폰 코드를 포함한 캠페인 정보를 검색합니다.

**요청:**
```proto
message GetCampaignRequest {
  string name = 1;
}
```

### IssueCoupon
특정 캠페인에 대한 쿠폰 발급을 요청합니다.

**요청:**
```proto
message IssueCouponRequest {
  string campaign_id = 1;
  string user_id = 2;
}
```

## 동시성 제어 메커니즘

이 시스템은 높은 트래픽 상황에서 데이터 일관성을 보장하기 위한 강력한 동시성 제어 메커니즘을 구현합니다:

### Redis 기반 분산 잠금

1. **원자적 카운터**: 각 캠페인은 Redis에 남은 쿠폰 수량에 대한 원자적 카운터를 유지합니다.
2. **사용자 집합**: Redis Set을 사용해 이미 쿠폰을 받은 사용자를 추적합니다.
3. **트랜잭션 흐름**:
    - 먼저 `SADD`를 사용하여 사용자가 이미 집합에 있는지 확인합니다(존재하지 않는 경우에만 원자적으로 추가).
    - 그 다음 `DECR`을 사용하여 쿠폰 카운터를 원자적으로 감소시킵니다.
    - 카운터가 0 미만으로 내려가면 작업을 롤백합니다.
    - 성공하면 데이터베이스에 쿠폰 레코드를 생성합니다.

이 접근 방식은 다음을 보장합니다:
- 지정된 수보다 많은 쿠폰이 발급되지 않음
- 사용자는 동일한 쿠폰을 두 번 받을 수 없음
- 경쟁 상태(race condition)가 올바르게 처리됨

### 장애 복구 메커니즘

이 시스템은 트랜잭션의 일부가 실패할 경우 자동 롤백 기능을 포함합니다:
- 데이터베이스 저장이 실패하면 Redis 상태가 복원됩니다
- Redis 작업이 실패하면 적절한 복구 처리를 통해 일관된 상태를 보장합니다

## 테스트 전략

application 의 public 메서드 기능 단위로, 실행 시 발생할 수 있는 성공 / 실패 케이스들에 대하여 테스트 합니다.<br/>
DB 접근의 경우 testcontainers 환경을 세팅하여 테스트 환경에서도 DB access 동작을 직접 수행하도록 하여 기능에 대한 다양한 테스트를 진행하였습니다.


### 통합 테스트

- **격리된 환경**: Testcontainers 환경을 세팅하여, Docker 컨테이너를 사용하여 테스트를 위한 격리된 Redis 및 MySQL 인스턴스를 생성합니다.

- **캠페인 시작/종료 날짜 유효성 검사**, **만료된 켐페인에 대한 오류 처리** 등... 다양한 엣지 케이스를 다루는 테스트 수행

**테스트 실행**
   ```shell
   go test ./internal/application/...
   ```


### 동시성 테스트

[coupon_test.go](internal/application/coupon_test.go)의 **TestCouponIssueConcurrencyWithContainer** 항목 테스트는 동시 액세스 상황에서 시스템의 동작을 검증합니다:
- **동시 요청**: 여러 사용자가 동시에 쿠폰을 요청하는 상황을 시뮬레이션합니다.
- **검증**: 다음을 확인합니다:
    - 정확히 지정된 수의 쿠폰만 발급됨
    - 동일 사용자에게 중복 쿠폰이 발급되지 않음
    - 실패한 요청이 적절히 처리됨

테스트 접근 방식 예:
```go
// 100개의 쿠폰이 있는 테스트 쿠폰 캠페인 생성
// 동시 사용자를 시뮬레이션하는 200개의 고루틴 실행
// 정확히 100개의 쿠폰이 발급되었는지 확인
// 어떤 사용자도 하나 이상의 쿠폰을 받지 않았는지 확인
```

## 시작하기

### 사전 요구 사항
- Go 1.24+
- Docker 및 Docker Compose

### 설정 및 실행

- Redis / MySQL 실행
   ```shell
   docker-compose up -d
   ```

- 로컬 환경에서 서버 실행
   ```shell
   go run cmd/client.go
   ```

## 설계 결정 및 트레이드오프

### 동시성 제어를 위한 Redis 사용
- **결정**: 데이터베이스 잠금 대신 Redis를 사용하여 동시 액세스 제어
- **이유**: **요청을 받는 서비스**와 **발급 처리 워커 서비스**를 분리하지 않고 하나의 서비스에서 최대한의 효율을 낼 수 있는 방안이라 판단
- **트레이드오프**: Redis와 데이터베이스가 동기화되지 않을 경우 일관성 문제가 발생할 수 있습니다

### 낙관적 동시성 제어
- **결정**: 비관적 잠금 대신 Redis 원자성을 활용한 낙관적 접근 방식 사용
- **이유**: 쿠폰 발급과 같은 높은 경합 시나리오에서 더 높은 처리량 제공
- **트레이드오프**: 실패 시 더 복잡한 롤백 로직 필요

## 향후 개선 사항
- **캐싱 데이터 만료일 지정**: 캠페인 만료일에 따른 캐싱 데이터 만료일 지정 로직 추가
- **모니터링 및 메트릭**: 시스템 성능에 대한 더 나은 관찰을 위한 Prometheus 메트릭 추가
- **회로 차단기**: Redis 사용 불가 상황을 우아하게 처리하기 위한 회로 차단기 패턴 구현
- **대량 발급 API**: 여러 쿠폰을 효율적으로 발급하기 위한 대량 작업 지원
- **캐싱 레이어**: 데이터베이스 부하를 줄이기 위한 캠페인 데이터 캐싱
- **속도 제한**: 남용으로부터 보호하기 위한 속도 제한 구현